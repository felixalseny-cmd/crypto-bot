require('dotenv').config();
const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const mongoose = require('mongoose');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;

// ==================== üîç –ü–†–û–í–ï–†–ö–ê –ü–ï–†–ï–ú–ï–ù–ù–´–• –û–ö–†–£–ñ–ï–ù–ò–Ø ====================
console.log('üîß Starting application from /app directory...');
console.log('üìã Checking environment variables...');
console.log('üìÅ Current directory:', __dirname);

const requiredEnvVars = ['BOT_TOKEN', 'MONGODB_URI', 'VIP_CHANNEL_ID', 'WALLET_ADDRESS'];
let missingVars = [];

requiredEnvVars.forEach(varName => {
  if (!process.env[varName]) {
    console.error(`‚ùå Missing required environment variable: ${varName}`);
    missingVars.push(varName);
  } else {
    console.log(`‚úÖ ${varName}: ${varName === 'BOT_TOKEN' ? '***' + process.env[varName].slice(-4) : process.env[varName]}`);
  }
});

if (missingVars.length > 0) {
  console.error('üö® Application cannot start without required environment variables');
  process.exit(1);
}

console.log('‚úÖ All environment variables are present');

// ==================== üóÑÔ∏è –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö MONGODB ====================
console.log('üîó Connecting to MongoDB...');

const MONGODB_URI = process.env.MONGODB_URI;

mongoose.connect(MONGODB_URI)
  .then(() => {
    console.log('‚úÖ Connected to MongoDB');
  })
  .catch(err => {
    console.error('‚ùå MongoDB connection error:', err.message);
    process.exit(1);
  });

// ==================== üë§ –ú–û–î–ï–õ–¨ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø ====================
const userSchema = new mongoose.Schema({
  userId: { type: Number, required: true, unique: true },
  username: String,
  firstName: String,
  subscription: {
    type: String,
    enum: ['none', '1month', '3months'],
    default: 'none'
  },
  expiresAt: Date,
  joinedAt: { type: Date, default: Date.now },
  transactions: [{
    hash: String,
    amount: Number,
    status: { type: String, default: 'pending' },
    timestamp: { type: Date, default: Date.now }
  }],
  pendingPayment: {
    plan: String,
    amount: Number,
    timestamp: Date
  }
});

const User = mongoose.model('User', userSchema);

// ==================== ü§ñ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø TELEGRAM –ë–û–¢–ê ====================
console.log('ü§ñ Initializing Telegram Bot...');

const bot = new TelegramBot(process.env.BOT_TOKEN, { 
  polling: true
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –±–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç
bot.getMe().then(botInfo => {
  console.log(`‚úÖ Telegram Bot started: @${botInfo.username}`);
}).catch(err => {
  console.error('‚ùå Telegram Bot initialization failed:', err.message);
  process.exit(1);
});

// ==================== üéØ –ö–û–ú–ê–ù–î–ê /START ====================
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  console.log(`üë§ User ${chatId} started bot`);

  try {
    const user = await User.findOneAndUpdate(
      { userId: chatId },
      {
        userId: chatId,
        username: msg.chat.username,
        firstName: msg.chat.first_name
      },
      { upsert: true, new: true }
    );

    const welcomeMessage = `üöÄ Welcome to FXWave VIP Access, ${msg.chat.first_name}!\n\nChoose your subscription plan:`;

    const options = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üìÖ 1 Month - 24 USDT', callback_data: 'subscribe_1month' },
            { text: '‚≠ê 3 Months - 55 USDT', callback_data: 'subscribe_3months' }
          ],
          [
            { text: '‚ÑπÔ∏è My Subscription', callback_data: 'my_subscription' },
            { text: 'üí≥ How to Pay', callback_data: 'how_to_pay' }
          ]
        ]
      }
    };

    await bot.sendMessage(chatId, welcomeMessage, options);
    console.log(`üì® Sent welcome message to user ${chatId}`);
  } catch (error) {
    console.error('Error in /start command:', error);
    await bot.sendMessage(chatId, '‚ùå An error occurred. Please try again.');
  }
});

// ==================== üîò –û–ë–†–ê–ë–û–¢–ö–ê CALLBACK –ö–ù–û–ü–û–ö ====================
bot.on('callback_query', async (callbackQuery) => {
  const message = callbackQuery.message;
  const data = callbackQuery.data;
  const chatId = message.chat.id;

  console.log(`üîò User ${chatId} pressed button: ${data}`);

  try {
    if (data.startsWith('subscribe_')) {
      const plan = data.split('_')[1];
      await sendPaymentInstructions(chatId, plan);
    } else if (data === 'my_subscription') {
      await showUserSubscription(chatId);
    } else if (data === 'how_to_pay') {
      await sendHowToPay(chatId);
    } else if (data === 'back_to_plans') {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–ª–∞–Ω–æ–≤
      const welcomeMessage = `üöÄ Choose your subscription plan:`;
      const options = {
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üìÖ 1 Month - 24 USDT', callback_data: 'subscribe_1month' },
              { text: '‚≠ê 3 Months - 55 USDT', callback_data: 'subscribe_3months' }
            ],
            [
              { text: '‚ÑπÔ∏è My Subscription', callback_data: 'my_subscription' },
              { text: 'üí≥ How to Pay', callback_data: 'how_to_pay' }
            ]
          ]
        }
      };
      await bot.editMessageText(welcomeMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        reply_markup: options.reply_markup
      });
    } else if (data === 'copy_wallet') {
      await bot.sendMessage(chatId, `üìã Wallet address copied to clipboard!\n\n${process.env.WALLET_ADDRESS}`);
    }
  } catch (error) {
    console.error('Error handling callback:', error);
    await bot.sendMessage(chatId, '‚ùå An error occurred. Please try again.');
  }
});

// ==================== üí≥ –§–£–ù–ö–¶–ò–Ø –û–¢–ü–†–ê–í–ö–ò –ò–ù–°–¢–†–£–ö–¶–ò–ô –ü–û –û–ü–õ–ê–¢–ï ====================
async function sendPaymentInstructions(chatId, plan) {
  const prices = { '1month': 24, '3months': 55 };
  const amount = prices[plan];
  const walletAddress = process.env.WALLET_ADDRESS;

  const message = `üí≥ *Payment Instructions for ${plan.toUpperCase()}*\n\nüìç Send exactly *${amount} USDT* (TRC20) to:\n\`${walletAddress}\`\n\n‚ö†Ô∏è *Important:*\n‚Ä¢ Send only USDT (TRC20)\n‚Ä¢ Send exact amount: *${amount} USDT*\n‚Ä¢ Network: *TRON (TRC20)*\n‚Ä¢ After payment, forward the transaction hash to this bot\n\nOnce verified, you'll get VIP access automatically!`;

  await bot.sendMessage(chatId, message, { 
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'üìã Copy Wallet Address', callback_data: 'copy_wallet' }],
        [{ text: 'üîô Back to Plans', callback_data: 'back_to_plans' }]
      ]
    }
  });

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–∂–∏–¥–∞–µ–º—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
  await User.findOneAndUpdate(
    { userId: chatId },
    { 
      $set: { 
        pendingPayment: { plan, amount, timestamp: new Date() }
      }
    }
  );

  console.log(`üí∞ Sent payment instructions to user ${chatId} for plan: ${plan}`);
}

// ==================== üìä –ü–û–ö–ê–ó–ê–¢–¨ –ò–ù–§–û–†–ú–ê–¶–ò–Æ –û –ü–û–î–ü–ò–°–ö–ï ====================
async function showUserSubscription(chatId) {
  const user = await User.findOne({ userId: chatId });
  
  if (!user || user.subscription === 'none') {
    await bot.sendMessage(chatId, 
      `üìä *Your Subscription Status*\n\n‚ùå No active subscription\nChoose a plan to get VIP access!`,
      { 
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üé´ View Plans', callback_data: 'back_to_plans' }]
          ]
        }
      }
    );
    return;
  }

  const remainingTime = Math.ceil((user.expiresAt - new Date()) / (1000 * 60 * 60 * 24));
  
  await bot.sendMessage(chatId,
    `üìä *Your Subscription Status*\n\n‚úÖ Plan: *${user.subscription.toUpperCase()}*\n‚è∞ Expires in: *${remainingTime} days*\nüìÖ Renewal: *${user.expiresAt.toLocaleDateString()}*`,
    { 
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîÑ Renew Subscription', callback_data: 'back_to_plans' }]
        ]
      }
    }
  );

  console.log(`üìä Sent subscription info to user ${chatId}`);
}

// ==================== üí° –ò–ù–°–¢–†–£–ö–¶–ò–Ø –ö–ê–ö –û–ü–õ–ê–¢–ò–¢–¨ ====================
async function sendHowToPay(chatId) {
  const message = `üí° *How to Pay with USDT*\n\n1. Open your crypto wallet (Trust Wallet, Binance, etc.)\n2. Select USDT and make sure to choose *TRON (TRC20)* network\n3. Send exact amount from the subscription plan\n4. Copy the *Transaction Hash (TXID)* after sending\n5. Forward the transaction hash to this bot\n\n‚è≥ Verification usually takes 5-15 minutes`;

  await bot.sendMessage(chatId, message, { 
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'üé´ View Subscription Plans', callback_data: 'back_to_plans' }]
      ]
    }
  );

  console.log(`üí° Sent payment instructions to user ${chatId}`);
}

// ==================== üì® –û–ë–†–ê–ë–û–¢–ö–ê –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô (–î–õ–Ø –¢–†–ê–ù–ó–ê–ö–¶–ò–ô) ====================
bot.on('message', async (msg) => {
  // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—ã
  if (msg.text && msg.text.startsWith('/')) return;
  
  const chatId = msg.chat.id;
  
  // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Ö—ç—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (64 —Å–∏–º–≤–æ–ª–∞, hex)
  if (msg.text && msg.text.length === 64 && /^[a-fA-F0-9]+$/.test(msg.text)) {
    console.log(`üîç Received transaction hash from user ${chatId}: ${msg.text.substring(0, 12)}...`);
    
    await bot.sendMessage(chatId, 
      `‚è≥ Transaction received! Verifying hash: ${msg.text.substring(0, 12)}...\n\nThis may take a few minutes. We'll notify you once verified.`,
      { parse_mode: 'Markdown' }
    );
    
    // –ò–º–∏—Ç–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
    setTimeout(async () => {
      try {
        // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É
        const user = await User.findOne({ userId: chatId });
        if (user && user.pendingPayment) {
          const { plan } = user.pendingPayment;
          const expiresAt = new Date();
          expiresAt.setMonth(expiresAt.getMonth() + (plan === '1month' ? 1 : 3));
          
          await User.findOneAndUpdate(
            { userId: chatId },
            {
              subscription: plan,
              expiresAt,
              $unset: { pendingPayment: 1 },
              $push: {
                transactions: {
                  hash: msg.text,
                  amount: user.pendingPayment.amount,
                  status: 'completed',
                  timestamp: new Date()
                }
              }
            }
          );

          await bot.sendMessage(chatId,
            `‚úÖ *Payment Verified!*\n\nYour ${plan} VIP subscription has been activated! You now have access to premium signals.`,
            { parse_mode: 'Markdown' }
          );

          console.log(`‚úÖ Activated ${plan} subscription for user ${chatId}`);
        }
      } catch (error) {
        console.error('Error activating subscription:', error);
        await bot.sendMessage(chatId, '‚ùå Error activating subscription. Please contact support.');
      }
    }, 10000);
  }
});

// ==================== üåê –ù–ê–°–¢–†–û–ô–ö–ê Express.js –î–õ–Ø WEB-–ò–ù–¢–ï–†–§–ï–ô–°–ê ====================

// Middleware
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è –≤–µ–±-—Å—Ç—Ä–∞–Ω–∏—Ü—ã
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Health check route –¥–ª—è Render
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    service: 'FXWave Crypto Bot',
    directory: __dirname
  });
});

// ==================== üöÄ –ó–ê–ü–£–°–ö –°–ï–†–í–ï–†–ê ====================
app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
  console.log(`üìÅ Application directory: ${__dirname}`);
  console.log(`üåê Web interface: http://localhost:${PORT}`);
  console.log(`‚ù§Ô∏è  Health check: http://localhost:${PORT}/health`);
  console.log('=========================================');
  console.log('‚úÖ Application started successfully!');
  console.log('=========================================');
});

// ==================== üîÑ –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö ====================
process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
});