require('dotenv').config();
const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const mongoose = require('mongoose');
const QRCode = require('qrcode');
const path = require('path');
const app = express();
const PORT = process.env.PORT || 10000;

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
const required = [
  'BOT_TOKEN',
  'MONGODB_URI',
  'VIP_CHANNEL_ID',
  'USDT_WALLET_ADDRESS',
  'TON_WALLET_ADDRESS'
];
for (const key of required) {
  if (!process.env[key]) {
    console.error(`‚ùå Missing ${key}`);
    process.exit(1);
  }
}

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB
mongoose.connect(process.env.MONGODB_URI)
  .then(() => console.log('‚úÖ MongoDB connected'))
  .catch(err => {
    console.error('‚ùå MongoDB error:', err.message);
    setTimeout(() => process.exit(1), 5000);
  });

// –ú–æ–¥–µ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
const userSchema = new mongoose.Schema({
  userId: { type: Number, required: true, unique: true },
  username: String,
  firstName: String,
  subscription: { type: String, default: 'none' },
  expiresAt: Date,
  pendingPayment: { plan: String, amount: Number, currency: String },
  transactions: [{
    hash: String,
    amount: Number,
    currency: { type: String, default: 'USDT' },
    status: { type: String, default: 'pending' },
    timestamp: { type: Date, default: Date.now }
  }]
});

const User = mongoose.model('User', userSchema);

// Telegram Bot
const bot = new TelegramBot(process.env.BOT_TOKEN, { polling: true });

// –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  await User.findOneAndUpdate(
    { userId: chatId },
    { userId: chatId, username: msg.chat.username, firstName: msg.chat.first_name },
    { upsert: true, setDefaultsOnInsert: true }
  );
  await bot.sendMessage(chatId, `üöÄ Welcome to FXWave VIP Access, ${msg.chat.first_name}!\nChoose your subscription plan:`, {
    reply_markup: {
      inline_keyboard: [
        [{ text: 'üìÖ 1 Month', callback_data: 'select_plan_1month' }],
        [{ text: '‚≠ê 3 Months', callback_data: 'select_plan_3months' }],
        [{ text: '‚ÑπÔ∏è My Subscription', callback_data: 'my_subscription' }]
      ]
    }
  });
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫
bot.on('callback_query', async (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const data = callbackQuery.data;

  try {
    if (data.startsWith('select_plan_')) {
      const plan = data.split('_')[2];
      await bot.editMessageText(
        `üí≥ Choose payment currency for <b>${plan === '1month' ? '1 Month' : '3 Months'}</b>:`,
        {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          parse_mode: 'HTML',
          reply_markup: {
            inline_keyboard: [
              [{ text: 'ü™ô TON', callback_data: `pay_TON_${plan}` }],
              [{ text: 'üíµ USDT (TRC20)', callback_data: `pay_USDT_${plan}` }],
              [{ text: 'üîô Back', callback_data: 'back_to_start' }]
            ]
          }
        }
      );
    } else if (data.startsWith('pay_')) {
      const [_, currency, plan] = data.split('_');
      const prices = {
        USDT: { '1month': 24, '3months': 55 },
        TON: { '1month': 11, '3months': 25 }
      };
      const amount = prices[currency][plan];
      const wallet = currency === 'TON'
        ? process.env.TON_WALLET_ADDRESS
        : process.env.USDT_WALLET_ADDRESS;

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è QR —Å —Å—É–º–º–æ–π
      let qrData;
      if (currency === 'TON') {
        const nanoTons = Math.round(amount * 1e9);
        qrData = `ton://transfer/${wallet}?amount=${nanoTons}`;
      } else {
        qrData = `tron:${wallet}?amount=${amount}`;
      }

      const qrBuffer = await QRCode.toBuffer(qrData, { errorCorrectionLevel: 'M' });
      await bot.sendPhoto(chatId, qrBuffer, {
        caption: currency === 'TON'
          ? `üí≥ <b>Pay with TON</b>\nüìç Send exactly <b>${amount} TON</b> to:\n<code>${wallet}</code>\n<i>–î–∞–Ω–Ω—ã–π –∞–¥—Ä–µ—Å –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã TON</i>`
          : `üí≥ <b>Pay with USDT (TRC20)</b>\nüìç Send exactly <b>${amount} USDT</b> to:\n<code>${wallet}</code>\n‚ö†Ô∏è Network: <b>TRON (TRC20)</b>`,
        parse_mode: 'HTML',
        reply_markup: {
          inline_keyboard: [[{ text: 'üîô Back to Plans', callback_data: 'back_to_start' }]]
        }
      });

      await User.findOneAndUpdate({ userId: chatId }, {
        $set: { pendingPayment: { plan, amount, currency } }
      });

    } else if (data === 'my_subscription') {
      const user = await User.findOne({ userId: chatId });
      if (!user || user.subscription === 'none') {
        await bot.sendMessage(chatId,
          `üìä <b>Your Subscription Status</b>\n‚ùå No active subscription\nChoose a plan to get VIP access!`,
          { parse_mode: 'HTML', reply_markup: { inline_keyboard: [[{ text: 'üé´ View Plans', callback_data: 'back_to_start' }]] } }
        );
      } else {
        const now = new Date();
        const days = user.expiresAt > now ? Math.ceil((user.expiresAt - now) / (1000 * 60 * 60 * 24)) : 0;
        await bot.sendMessage(chatId,
          `üìä <b>Your Subscription Status</b>\n` +
          `‚úÖ Plan: <b>${user.subscription.toUpperCase()}</b>\n` +
          `‚è∞ Expires in: <b>${days} days</b>\n` +
          `üìÖ Expiry: <b>${user.expiresAt.toLocaleDateString()}</b>`,
          { parse_mode: 'HTML', reply_markup: { inline_keyboard: [[{ text: 'üîÑ Renew', callback_data: 'back_to_start' }]] } }
        );
      }
    } else if (data === 'back_to_start') {
      await bot.deleteMessage(chatId, callbackQuery.message.message_id).catch(() => {});
      bot.emit('message', { chat: { id: chatId }, text: '/start' });
    }
  } catch (error) {
    console.error('Callback error:', error);
    await bot.sendMessage(chatId, '‚ùå An error occurred. Please try again.', { parse_mode: 'HTML' });
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ TXID
bot.on('message', async (msg) => {
  if (!msg.text || msg.text.startsWith('/')) return;
  const chatId = msg.chat.id;
  const tx = msg.text.trim();
  if (tx.length === 64 && /^[a-fA-F0-9]+$/.test(tx)) {
    await bot.sendMessage(chatId, '‚è≥ Verifying payment...', { parse_mode: 'HTML' });
    setTimeout(async () => {
      try {
        const user = await User.findOne({ userId: chatId });
        if (user && user.pendingPayment) {
          const { plan, amount, currency } = user.pendingPayment;
          const expiresAt = new Date();
          expiresAt.setMonth(expiresAt.getMonth() + (plan === '1month' ? 1 : 3));

          await User.findOneAndUpdate(
            { userId: chatId },
            {
              subscription: plan,
              expiresAt,
              $unset: { pendingPayment: 1 },
              $push: {
                transactions: {
                  hash: tx,
                  amount,
                  currency,
                  status: 'completed',
                  timestamp: new Date()
                }
              }
            }
          );

          let added = false;
          try {
            await bot.addChatMember(process.env.VIP_CHANNEL_ID, chatId);
            added = true;
          } catch (e) {
            if (e.response?.body?.description?.includes('USER_ALREADY_PARTICIPANT')) {
              added = true;
            }
          }

          if (added) {
            await bot.sendMessage(chatId,
              `‚úÖ <b>Payment Verified!</b>\nYour <b>${plan}</b> VIP subscription has been activated!\nüéâ You‚Äôve been added to the VIP channel!`,
              { parse_mode: 'HTML' }
            );
          } else {
            await bot.sendMessage(chatId,
              `‚úÖ <b>Payment Verified!</b>\nYour <b>${plan}</b> VIP subscription has been activated!\n‚ö†Ô∏è <b>Could not add you to VIP channel.</b> Please contact support: @fxfeelgood`,
              { parse_mode: 'HTML' }
            );
          }
        } else {
          await bot.sendMessage(chatId,
            '‚ö†Ô∏è No pending subscription found. Please select a plan first via /start.',
            { parse_mode: 'HTML' }
          );
        }
      } catch (error) {
        console.error('Error activating subscription:', error);
        await bot.sendMessage(chatId, '‚ùå Error. Please contact support: @fxfeelgood', { parse_mode: 'HTML' });
      }
    }, 8000);
  }
});

// –ö–æ–º–∞–Ω–¥–∞ /testchannel
bot.onText(/\/testchannel/, async (msg) => {
  const chatId = msg.chat.id;
  try {
    const chat = await bot.getChat(process.env.VIP_CHANNEL_ID);
    await bot.sendMessage(chatId, `‚úÖ Channel: ${chat.title}`, { parse_mode: 'HTML' });
    const admins = await bot.getChatAdministrators(process.env.VIP_CHANNEL_ID);
    const botInfo = await bot.getMe();
    const isBotAdmin = admins.some(a => a.user.id === botInfo.id && a.can_invite_users);
    await bot.sendMessage(chatId, isBotAdmin ? '‚úÖ Bot is admin with invite rights' : '‚ùå Bot is NOT admin');
  } catch (e) {
    await bot.sendMessage(chatId, `‚ùå Error: ${e.message}`);
  }
});

// Web server
app.use(express.static('public'));
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});
app.get('/health', (req, res) => {
  res.json({ status: 'OK', db: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected' });
});

// –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è QR-–∫–æ–¥–æ–≤ —Å —Å—É–º–º–æ–π
app.get('/qr', async (req, res) => {
  const { currency, plan } = req.query;
  const usdtWallet = process.env.USDT_WALLET_ADDRESS;
  const tonWallet = process.env.TON_WALLET_ADDRESS;

  const prices = {
    USDT: { '1month': 24, '3months': 55 },
    TON: { '1month': 11, '3months': 25 }
  };

  const amount = prices[currency]?.[plan] || (currency === 'TON' ? 11 : 24);
  let data = '';

  if (currency === 'TON') {
    const nanoTons = Math.round(amount * 1e9);
    data = `ton://transfer/${tonWallet}?amount=${nanoTons}`;
  } else {
    data = `tron:${usdtWallet}?amount=${amount}`;
  }

  try {
    const qrBuffer = await QRCode.toBuffer(data, { errorCorrectionLevel: 'M' });
    res.setHeader('Content-Type', 'image/png');
    res.setHeader('Cache-Control', 'public, max-age=3600');
    res.send(qrBuffer);
  } catch (err) {
    console.error('QR error:', err);
    res.status(500).send('QR generation failed');
  }
});

// Keep-alive –¥–ª—è Render
if (process.env.RENDER_EXTERNAL_URL) {
  setInterval(async () => {
    try {
      await fetch(`${process.env.RENDER_EXTERNAL_URL}/health`);
    } catch (e) { /* ignore */ }
  }, 14 * 60 * 1000);
}

// –£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫ ‚Äî –í–ù–ï –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–π!
setInterval(async () => {
  const now = new Date();
  const expired = await User.find({
    expiresAt: { $lt: now },
    subscription: { $ne: 'none' }
  });
  for (const user of expired) {
    try {
      await bot.banChatMember(process.env.VIP_CHANNEL_ID, user.userId);
      await bot.unbanChatMember(process.env.VIP_CHANNEL_ID, user.userId);
      user.subscription = 'none';
      await user.save();
      await bot.sendMessage(user.userId, "‚ùå Your VIP subscription has expired.");
    } catch (e) {
      console.log("Failed to remove user", user.userId, e.message);
    }
  }
}, 60 * 60 * 1000);

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
process.on('unhandledRejection', (reason) => {
  console.error('‚ùå Unhandled Rejection:', reason);
});
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
  process.exit(1);
});