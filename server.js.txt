require('dotenv').config();
const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const mongoose = require('mongoose');
const QRCode = require('qrcode');
const path = require('path');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 10000;

// üöÄ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –°–£–ü–ï–†-–ë–û–¢–ê
const SUPER_CONFIG = {
  PRICES: {
    USDT: { '1month': 24, '3months': 55 },
    TON: { '1month': 11, '3months': 25 }
  },
  PAYMENT_TIMEOUT: 10000,
  CLEANUP_INTERVAL: 30 * 60 * 1000, // –ö–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
  KEEP_ALIVE_INTERVAL: 10 * 60 * 1000, // –ö–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
  TX_HASH_LENGTH: 64,
  MAX_RETRIES: 3,
  RETRY_DELAY: 2000
};

// üîê –°–£–ü–ï–†-–ü–†–û–í–ï–†–ö–ê –ü–ï–†–ï–ú–ï–ù–ù–´–• –û–ö–†–£–ñ–ï–ù–ò–Ø
const superValidateEnvironment = () => {
  console.log('üîç Running SUPER environment validation...');
  
  const required = ['BOT_TOKEN', 'MONGODB_URI', 'VIP_CHANNEL_ID'];
  const walletRequired = ['USDT_WALLET_ADDRESS', 'TON_WALLET_ADDRESS'];
  
  let hasErrors = false;
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
  for (const key of required) {
    if (!process.env[key]) {
      console.error(`‚ùå CRITICAL: Missing required environment variable: ${key}`);
      hasErrors = true;
    } else {
      console.log(`‚úÖ ${key}: ‚úì`);
    }
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—à–µ–ª—å–∫–æ–≤
  for (const key of walletRequired) {
    if (!process.env[key]) {
      console.warn(`‚ö†Ô∏è WARNING: Missing wallet address: ${key}`);
    } else {
      console.log(`‚úÖ ${key}: ‚úì`);
    }
  }
  
  if (hasErrors) {
    console.error('üö® SUPER BOT: Critical environment variables missing! Shutting down...');
    process.exit(1);
  }
  
  console.log('üéâ SUPER environment validation PASSED!');
};

superValidateEnvironment();

// üóÑÔ∏è –°–£–ü–ï–†-–ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö MONGODB
const superConnectDB = async (retryCount = 0) => {
  try {
    console.log(`üîÑ SUPER DB: Connecting to MongoDB... (Attempt ${retryCount + 1})`);
    
    await mongoose.connect(process.env.MONGODB_URI, {
      serverSelectionTimeoutMS: 10000,
      socketTimeoutMS: 45000,
      maxPoolSize: 10,
      retryWrites: true,
      w: 'majority'
    });
    
    console.log('üéâ SUPER DB: MongoDB connected successfully!');
    return true;
  } catch (error) {
    console.error(`‚ùå SUPER DB: Connection failed (Attempt ${retryCount + 1}):`, error.message);
    
    if (retryCount < SUPER_CONFIG.MAX_RETRIES - 1) {
      console.log(`üîÑ SUPER DB: Retrying in ${SUPER_CONFIG.RETRY_DELAY / 1000} seconds...`);
      await new Promise(resolve => setTimeout(resolve, SUPER_CONFIG.RETRY_DELAY));
      return superConnectDB(retryCount + 1);
    } else {
      console.error('üö® SUPER DB: Maximum retry attempts reached. Shutting down...');
      process.exit(1);
    }
  }
};

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π MongoDB
mongoose.connection.on('disconnected', () => {
  console.warn('‚ö†Ô∏è SUPER DB: MongoDB disconnected! Attempting to reconnect...');
  setTimeout(() => superConnectDB(), 5000);
});

mongoose.connection.on('error', (err) => {
  console.error('‚ùå SUPER DB: MongoDB error:', err);
});

// üë§ –°–£–ü–ï–†-–ú–û–î–ï–õ–¨ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø
const userSchema = new mongoose.Schema({
  userId: { 
    type: Number, 
    required: true, 
    unique: true, 
    index: true 
  },
  username: { 
    type: String, 
    index: true 
  },
  firstName: String,
  subscription: { 
    type: String, 
    default: 'none', 
    enum: ['none', '1month', '3months'] 
  },
  expiresAt: { 
    type: Date, 
    index: true 
  },
  pendingPayment: {
    plan: String,
    amount: Number,
    currency: String,
    paymentId: String,
    createdAt: { 
      type: Date, 
      default: Date.now,
      expires: 3600 // –ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 1 —á–∞—Å
    }
  },
  transactions: [{
    hash: { 
      type: String, 
      unique: true, 
      sparse: true 
    },
    amount: Number,
    currency: String,
    status: { 
      type: String, 
      default: 'pending', 
      enum: ['pending', 'completed', 'failed', 'verified'] 
    },
    timestamp: { 
      type: Date, 
      default: Date.now 
    },
    verified: { 
      type: Boolean, 
      default: false 
    },
    paymentId: String
  }],
  lastActivity: { 
    type: Date, 
    default: Date.now,
    index: true 
  },
  joinDate: { 
    type: Date, 
    default: Date.now 
  }
}, {
  timestamps: true
});

// –°–£–ü–ï–†-–ò–ù–î–ï–ö–°–´ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
userSchema.index({ 'transactions.hash': 1 });
userSchema.index({ expiresAt: 1, subscription: 1 });
userSchema.index({ 'pendingPayment.createdAt': 1 }, { expireAfterSeconds: 3600 });

const User = mongoose.model('User', userSchema);

// ü§ñ –°–£–ü–ï–†-TELEGRAM BOT
const bot = new TelegramBot(process.env.BOT_TOKEN, {
  polling: {
    interval: 300,
    autoStart: true,
    params: {
      timeout: 10,
      limit: 100
    }
  },
  request: {
    timeout: 15000,
    agent: null
  }
});

// üõ†Ô∏è –°–£–ü–ï–†-–£–¢–ò–õ–ò–¢–´
const superLogger = (event, userId, details = {}) => {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    event,
    userId,
    ...details
  };
  console.log(`üìä SUPER LOG [${timestamp}] ${event} - User: ${userId}`, details);
  return logEntry;
};

const superValidateTxHash = (hash) => {
  return hash && 
         hash.length === SUPER_CONFIG.TX_HASH_LENGTH && 
         /^[a-fA-F0-9]+$/.test(hash);
};

const superGeneratePaymentId = () => {
  return `pay_${crypto.randomBytes(12).toString('hex')}`;
};

const superCalculateExpiry = (plan) => {
  const expiry = new Date();
  const months = plan === '1month' ? 1 : 3;
  expiry.setMonth(expiry.getMonth() + months);
  return expiry;
};

const superRetryOperation = async (operation, operationName, maxRetries = 3) => {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      console.warn(`‚ö†Ô∏è SUPER RETRY: ${operationName} attempt ${attempt} failed:`, error.message);
      if (attempt === maxRetries) {
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, SUPER_CONFIG.RETRY_DELAY * attempt));
    }
  }
};

// üè† –°–£–ü–ï–†-–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  
  try {
    await superRetryOperation(async () => {
      await User.findOneAndUpdate(
        { userId: chatId },
        { 
          userId: chatId, 
          username: msg.chat.username, 
          firstName: msg.chat.first_name,
          lastActivity: new Date()
        },
        { 
          upsert: true, 
          setDefaultsOnInsert: true,
          new: true 
        }
      );
    }, "User update");

    const superKeyboard = [
      [{ text: 'üìÖ 1 MONTH VIP', callback_data: 'select_plan_1month' }],
      [{ text: '‚≠ê 3 MONTHS VIP', callback_data: 'select_plan_3months' }],
      [{ text: 'üîç MY SUBSCRIPTION', callback_data: 'my_subscription' }],
      [
        { text: 'üìû SUPPORT', url: 'https://t.me/fxfeelgood' },
        { text: 'üìÑ TERMS', url: `${process.env.RENDER_EXTERNAL_URL || 'http://localhost:10000'}/offer` }
      ]
    ];

    const welcomeMessage = `
üöÄ <b>WELCOME TO FXWAVE VIP ACCESS</b>, ${msg.chat.first_name}!

üíé <b>PREMIUM TRADING SIGNALS</b>
‚úÖ High-accuracy forex & crypto signals
‚úÖ Real-time market analysis  
‚úÖ Professional trading insights
‚úÖ 24/7 support

üéØ <b>CHOOSE YOUR VIP PLAN:</b>
    `;

    await bot.sendMessage(chatId, welcomeMessage, {
      parse_mode: 'HTML',
      reply_markup: { inline_keyboard: superKeyboard },
      disable_web_page_preview: true
    });

    superLogger('SUPER_START', chatId, { 
      username: msg.chat.username,
      firstName: msg.chat.first_name 
    });

  } catch (error) {
    console.error('‚ùå SUPER START ERROR:', error);
    await bot.sendMessage(chatId, 
      '‚ùå <b>System temporarily unavailable</b>\nPlease try again in a few moments.',
      { parse_mode: 'HTML' }
    );
  }
});

// üñ±Ô∏è –°–£–ü–ï–†-–û–ë–†–ê–ë–û–¢–ö–ê –ö–ù–û–ü–û–ö
bot.on('callback_query', async (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const messageId = callbackQuery.message.message_id;
  const data = callbackQuery.data;

  try {
    // –í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback query
    await bot.answerCallbackQuery(callbackQuery.id);

    if (data.startsWith('select_plan_')) {
      await superHandlePlanSelection(chatId, messageId, data);
    } else if (data.startsWith('pay_')) {
      await superHandlePayment(chatId, messageId, data);
    } else if (data === 'my_subscription') {
      await superHandleSubscription(chatId);
    } else if (data === 'back_to_start') {
      await superHandleBack(chatId, messageId);
    }
  } catch (error) {
    console.error('‚ùå SUPER CALLBACK ERROR:', error);
    await bot.sendMessage(chatId, 
      '‚ùå <b>Action failed</b>\nPlease try again or contact support.',
      { parse_mode: 'HTML' }
    );
    
    superLogger('SUPER_CALLBACK_ERROR', chatId, { 
      error: error.message, 
      data 
    });
  }
});

// üîß –°–£–ü–ï–†-–û–ë–†–ê–ë–û–¢–ß–ò–ö–ò
async function superHandlePlanSelection(chatId, messageId, data) {
  const plan = data.split('_')[2];
  const planName = plan === '1month' ? '1 MONTH' : '3 MONTHS';
  
  const currencyButtons = [];
  
  if (process.env.TON_WALLET_ADDRESS) {
    currencyButtons.push([
      { 
        text: `ü™ô PAY WITH TON - ${SUPER_CONFIG.PRICES.TON[plan]} TON`, 
        callback_data: `pay_TON_${plan}` 
      }
    ]);
  }
  
  if (process.env.USDT_WALLET_ADDRESS) {
    currencyButtons.push([
      { 
        text: `üíµ PAY WITH USDT - ${SUPER_CONFIG.PRICES.USDT[plan]} USDT`, 
        callback_data: `pay_USDT_${plan}` 
      }
    ]);
  }

  if (currencyButtons.length === 0) {
    await bot.editMessageText(
      '‚ùå <b>PAYMENT UNAVAILABLE</b>\n\nAll payment methods are currently disabled.\nPlease contact support: @fxfeelgood',
      { 
        chat_id: chatId, 
        message_id: messageId,
        parse_mode: 'HTML'
      }
    );
    return;
  }

  currencyButtons.push([{ text: 'üîô BACK TO PLANS', callback_data: 'back_to_start' }]);

  const message = `
üíé <b>${planName} VIP SUBSCRIPTION</b>

üí∞ <b>PRICING:</b>
${process.env.TON_WALLET_ADDRESS ? `ü™ô ${SUPER_CONFIG.PRICES.TON[plan]} TON` : ''}
${process.env.USDT_WALLET_ADDRESS ? `üíµ ${SUPER_CONFIG.PRICES.USDT[plan]} USDT` : ''}

üìä <b>BENEFITS:</b>
‚úÖ Premium trading signals
‚úÖ Real-time market analysis
‚úÖ 24/7 VIP support
‚úÖ High accuracy forecasts

üí≥ <b>CHOOSE PAYMENT METHOD:</b>
  `;

  await bot.editMessageText(message, {
    chat_id: chatId,
    message_id: messageId,
    parse_mode: 'HTML',
    reply_markup: { inline_keyboard: currencyButtons }
  });

  superLogger('SUPER_PLAN_SELECTED', chatId, { plan });
}

async function superHandlePayment(chatId, messageId, data) {
  const [_, currency, plan] = data.split('_');
  const wallet = currency === 'TON' ? process.env.TON_WALLET_ADDRESS : process.env.USDT_WALLET_ADDRESS;
  
  if (!wallet) {
    await bot.answerCallbackQuery({
      text: `‚ùå ${currency} payments are currently unavailable`,
      show_alert: true
    });
    return;
  }

  const amount = SUPER_CONFIG.PRICES[currency][plan];
  const paymentId = superGeneratePaymentId();
  
  let qrData, instructions;

  if (currency === 'TON') {
    const nanoTons = Math.round(amount * 1e9);
    qrData = `ton://transfer/${wallet}?amount=${nanoTons}`;
    instructions = `
üí≥ <b>PAY WITH TON</b>

üìç Send exactly <b>${amount} TON</b> to:
<code>${wallet}</code>

‚ö†Ô∏è <b>IMPORTANT:</b>
‚Ä¢ Use TON network ONLY
‚Ä¢ Send exact amount
‚Ä¢ Network: <b>TON</b>
‚Ä¢ Payment ID: <code>${paymentId}</code>
    `;
  } else {
    qrData = `tron:${wallet}?amount=${amount}`;
    instructions = `
üí≥ <b>PAY WITH USDT (TRC20)</b>

üìç Send exactly <b>${amount} USDT</b> to:
<code>${wallet}</code>

‚ö†Ô∏è <b>CRITICAL:</b>
‚Ä¢ Network: <b>TRON (TRC20) ONLY</b>
‚Ä¢ Send exact amount
‚Ä¢ Do NOT use other networks
‚Ä¢ Payment ID: <code>${paymentId}</code>
    `;
  }

  try {
    const qrBuffer = await QRCode.toBuffer(qrData, { 
      errorCorrectionLevel: 'H',
      width: 400,
      margin: 4,
      color: {
        dark: '#000000',
        light: '#FFFFFF'
      }
    });

    await bot.sendPhoto(chatId, qrBuffer, {
      caption: instructions + `\n\nüì® After payment, send your <b>Transaction Hash (TXID)</b> here.`,
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîô CHOOSE DIFFERENT PLAN', callback_data: 'back_to_start' }],
          [{ text: 'üÜò NEED HELP?', url: 'https://t.me/fxfeelgood' }]
        ]
      }
    });

    await superRetryOperation(async () => {
      await User.findOneAndUpdate(
        { userId: chatId },
        { 
          $set: { 
            pendingPayment: { 
              plan, 
              amount, 
              currency,
              paymentId,
              createdAt: new Date()
            } 
          } 
        }
      );
    }, "Payment setup");

    superLogger('SUPER_PAYMENT_INITIATED', chatId, { 
      plan, 
      currency, 
      amount, 
      paymentId 
    });

  } catch (error) {
    console.error('‚ùå SUPER PAYMENT ERROR:', error);
    await bot.sendMessage