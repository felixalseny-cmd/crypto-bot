require('dotenv').config();
const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const mongoose = require('mongoose');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;

// ==================== üîß –ü–†–û–í–ï–†–ö–ê –ü–ï–†–ï–ú–ï–ù–ù–´–• –û–ö–†–£–ñ–ï–ù–ò–Ø ====================
console.log('üöÄ Starting FXWave Crypto Bot...');

const requiredEnvVars = ['BOT_TOKEN', 'MONGODB_URI', 'VIP_CHANNEL_ID', 'WALLET_ADDRESS'];
requiredEnvVars.forEach(varName => {
  if (!process.env[varName]) {
    console.error(`‚ùå Missing environment variable: ${varName}`);
    process.exit(1);
  }
  console.log(`‚úÖ ${varName}: ${varName === 'BOT_TOKEN' ? '***' + process.env[varName].slice(-4) : 'Set'}`);
});

// ==================== üóÑÔ∏è –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö MONGODB ====================
console.log('üîó Connecting to MongoDB...');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
    });
    console.log('‚úÖ Successfully connected to MongoDB');
  } catch (error) {
    console.error('‚ùå MongoDB connection failed:', error.message);
    setTimeout(connectDB, 10000);
  }
};

connectDB();

// ==================== üë§ –ú–û–î–ï–õ–¨ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø ====================
const userSchema = new mongoose.Schema({
  userId: { type: Number, required: true, unique: true },
  username: String,
  firstName: String,
  subscription: {
    type: String,
    enum: ['none', '1month', '3months'],
    default: 'none'
  },
  expiresAt: Date,
  joinedAt: { type: Date, default: Date.now },
  transactions: [{
    hash: String,
    amount: Number,
    status: { type: String, default: 'pending' },
    timestamp: { type: Date, default: Date.now }
  }],
  pendingPayment: {
    plan: String,
    amount: Number,
    timestamp: Date
  },
  inVipChannel: { type: Boolean, default: false }
});

const User = mongoose.model('User', userSchema);

// ==================== ü§ñ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø TELEGRAM –ë–û–¢–ê ====================
let bot;

const initializeBot = () => {
  console.log('ü§ñ Initializing Telegram Bot...');
  bot = new TelegramBot(process.env.BOT_TOKEN, { polling: true });

  bot.getMe().then(botInfo => {
    console.log(`‚úÖ Telegram Bot started: @${botInfo.username}`);
    setupBotHandlers();
  }).catch(err => {
    console.error('‚ùå Telegram Bot failed:', err);
    setTimeout(initializeBot, 10000);
  });
};

mongoose.connection.on('connected', () => {
  initializeBot();
});

// ==================== üéØ –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° VIP –ö–ê–ù–ê–õ–û–ú ====================
async function addToVipChannel(chatId) {
  if (!bot) return false;
  try {
    await bot.addChatMember(process.env.VIP_CHANNEL_ID, chatId);
    await User.findOneAndUpdate({ userId: chatId }, { inVipChannel: true });
    return true;
  } catch (error) {
    if (error.response?.body?.description?.includes('USER_ALREADY_PARTICIPANT')) {
      await User.findOneAndUpdate({ userId: chatId }, { inVipChannel: true });
      return true;
    }
    console.error(`‚ùå Failed to add ${chatId} to channel:`, error.message);
    return false;
  }
}

// ==================== üí¨ –û–°–ù–û–í–ù–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ë–û–¢–ê ====================
function setupBotHandlers() {
  const sendStartMessage = async (chatId, firstName) => {
    const welcomeMessage = `üöÄ <b>Welcome to FXWave VIP Access, ${firstName}!</b>\n\nChoose your subscription plan:`;
    const options = {
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üìÖ 1 Month - 24 USDT', callback_data: 'subscribe_1month' },
            { text: '‚≠ê 3 Months - 55 USDT', callback_data: 'subscribe_3months' }
          ],
          [
            { text: '‚ÑπÔ∏è My Subscription', callback_data: 'my_subscription' },
            { text: 'üí≥ How to Pay', callback_data: 'how_to_pay' }
          ]
        ]
      }
    };
    await bot.sendMessage(chatId, welcomeMessage, options);
  };

  bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;
    await User.findOneAndUpdate(
      { userId: chatId },
      {
        userId: chatId,
        username: msg.chat.username,
        firstName: msg.chat.first_name
      },
      { upsert: true }
    );
    await sendStartMessage(chatId, msg.chat.first_name);
  });

  bot.on('callback_query', async (callbackQuery) => {
    const message = callbackQuery.message;
    const data = callbackQuery.data;
    const chatId = message.chat.id;

    try {
      if (data.startsWith('subscribe_')) {
        const plan = data.split('_')[1];
        await sendPaymentInstructions(chatId, plan);
      } else if (data === 'my_subscription') {
        await showUserSubscription(chatId);
      } else if (data === 'how_to_pay') {
        await sendHowToPay(chatId);
      } else if (data === 'back_to_plans') {
        await bot.deleteMessage(chatId, message.message_id);
        const user = await User.findOne({ userId: chatId });
        await sendStartMessage(chatId, user?.firstName || 'User');
      }
    } catch (error) {
      console.error('Callback error:', error);
      await bot.sendMessage(chatId, '‚ùå An error occurred. Please try again.', { parse_mode: 'HTML' });
    }
  });

  async function sendPaymentInstructions(chatId, plan) {
    const prices = { '1month': 24, '3months': 55 };
    const amount = prices[plan];
    const walletAddress = process.env.WALLET_ADDRESS;

    const message = `üí≥ <b>Payment Instructions for ${plan.toUpperCase()}</b>\n\n` +
      `üìç Send exactly <b>${amount} USDT</b> (TRC20) to:\n\n` +
      `<code>${walletAddress}</code>\n\n` +
      `‚ö†Ô∏è <b>Important:</b>\n` +
      `‚Ä¢ Send only USDT (TRC20)\n` +
      `‚Ä¢ Send exact amount: <b>${amount} USDT</b>\n` +
      `‚Ä¢ Network: <b>TRON (TRC20)</b>\n` +
      `‚Ä¢ After payment, forward the transaction hash to this bot\n\n` +
      `Once verified, you'll get VIP access automatically!`;

    await bot.sendMessage(chatId, message, {
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîô Back to Plans', callback_data: 'back_to_plans' }]
        ]
      }
    });

    await User.findOneAndUpdate(
      { userId: chatId },
      { $set: { pendingPayment: { plan, amount, timestamp: new Date() } } }
    );
  }

  async function showUserSubscription(chatId) {
    const user = await User.findOne({ userId: chatId });
    if (!user || user.subscription === 'none') {
      await bot.sendMessage(chatId,
        `üìä <b>Your Subscription Status</b>\n\n‚ùå No active subscription\nChoose a plan to get VIP access!`,
        {
          parse_mode: 'HTML',
          reply_markup: {
            inline_keyboard: [
              [{ text: 'üé´ View Plans', callback_data: 'back_to_plans' }]
            ]
          }
        }
      );
      return;
    }

    const remainingTime = Math.ceil((user.expiresAt - new Date()) / (1000 * 60 * 60 * 24));
    await bot.sendMessage(chatId,
      `üìä <b>Your Subscription Status</b>\n\n` +
      `‚úÖ Plan: <b>${user.subscription.toUpperCase()}</b>\n` +
      `‚è∞ Expires in: <b>${remainingTime} days</b>\n` +
      `üìÖ Renewal: <b>${user.expiresAt.toLocaleDateString()}</b>\n` +
      `üéØ VIP Access: <b>${user.inVipChannel ? 'Active' : 'Pending'}</b>`,
      {
        parse_mode: 'HTML',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üîÑ Renew Subscription', callback_data: 'back_to_plans' }]
          ]
        }
      }
    );
  }

  async function sendHowToPay(chatId) {
    const message = `üí° <b>How to Pay with USDT</b>\n\n` +
      `1. Open your crypto wallet (Trust Wallet, Binance, etc.)\n` +
      `2. Select USDT and make sure to choose <b>TRON (TRC20)</b> network\n` +
      `3. Send exact amount from the subscription plan\n` +
      `4. Copy the <b>Transaction Hash (TXID)</b> after sending\n` +
      `5. Forward the transaction hash to this bot\n\n` +
      `‚è≥ Verification usually takes 5-15 minutes`;

    await bot.sendMessage(chatId, message, {
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üé´ View Subscription Plans', callback_data: 'back_to_plans' }]
        ]
      }
    );
  }

  bot.on('message', async (msg) => {
    if (msg.text && (msg.text.startsWith('/') || !/^[a-fA-F0-9]{64}$/.test(msg.text))) return;
    const chatId = msg.chat.id;

    await bot.sendMessage(chatId,
      `‚è≥ <b>Transaction received!</b> Verifying hash: <code>${msg.text.substring(0, 12)}...</code>\n\nThis may take a few minutes.`,
      { parse_mode: 'HTML' }
    );

    setTimeout(async () => {
      try {
        const user = await User.findOne({ userId: chatId });
        if (user && user.pendingPayment) {
          const { plan } = user.pendingPayment;
          const expiresAt = new Date();
          expiresAt.setMonth(expiresAt.getMonth() + (plan === '1month' ? 1 : 3));

          await User.findOneAndUpdate(
            { userId: chatId },
            {
              subscription: plan,
              expiresAt,
              $unset: { pendingPayment: 1 },
              $push: {
                transactions: {
                  hash: msg.text,
                  amount: user.pendingPayment.amount,
                  status: 'completed',
                  timestamp: new Date()
                }
              }
            }
          );

          const added = await addToVipChannel(chatId);
          if (added) {
            await bot.sendMessage(chatId,
              `‚úÖ <b>Payment Verified!</b>\n\nYour <b>${plan}</b> VIP subscription has been activated!\n\nüéâ <b>You have been automatically added to the VIP channel!</b>`,
              { parse_mode: 'HTML' }
            );
          } else {
            await bot.sendMessage(chatId,
              `‚úÖ <b>Payment Verified!</b>\n\nYour <b>${plan}</b> VIP subscription has been activated!\n\n‚ö†Ô∏è <b>Could not add you to VIP channel.</b> Please contact support.`,
              { parse_mode: 'HTML' }
            );
          }
        }
      } catch (error) {
        console.error('Error activating subscription:', error);
        await bot.sendMessage(chatId, '‚ùå Error activating subscription. Please contact support.', { parse_mode: 'HTML' });
      }
    }, 10000);
  });

  // ==================== üõ†Ô∏è –ö–û–ú–ê–ù–î–ê /testchannel ====================
  bot.onText(/\/testchannel/, async (msg) => {
    const chatId = msg.chat.id;
    try {
      const chat = await bot.getChat(process.env.VIP_CHANNEL_ID);
      await bot.sendMessage(chatId, `‚úÖ <b>Channel found:</b> ${chat.title}\nID: ${chat.id}`, { parse_mode: 'HTML' });

      const admins = await bot.getChatAdministrators(process.env.VIP_CHANNEL_ID);
      const botInfo = await bot.getMe();
      const isBotAdmin = admins.some(admin => admin.user.id === botInfo.id && admin.can_invite_users);

      if (isBotAdmin) {
        await bot.sendMessage(chatId, `‚úÖ <b>Bot is administrator</b> with invite rights.`, { parse_mode: 'HTML' });
      } else {
        await bot.sendMessage(chatId, `‚ùå <b>Bot is NOT administrator</b> or missing "Add members" permission.`, { parse_mode: 'HTML' });
      }

      const added = await addToVipChannel(chatId);
      if (added) {
        await bot.sendMessage(chatId, `‚úÖ <b>Test: successfully added to VIP channel.</b>`, { parse_mode: 'HTML' });
      } else {
        await bot.sendMessage(chatId, `‚ùå <b>Test: failed to add to VIP channel.</b>`, { parse_mode: 'HTML' });
      }
    } catch (error) {
      console.error('Test channel error:', error);
      await bot.sendMessage(chatId, `‚ùå <b>Test error:</b> ${error.message}`, { parse_mode: 'HTML' });
    }
  });
}

// ==================== üåê WEB –ò–ù–¢–ï–†–§–ï–ô–° ====================
app.use(express.json());
app.use(express.static('public'));

app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.get('/health', (req, res) => {
  const dbStatus = mongoose.connection.readyState === 1 ? 'connected' : 'disconnected';
  res.json({
    status: 'OK',
    database: dbStatus,
    service: 'FXWave Crypto Bot',
    timestamp: new Date().toISOString()
  });
});

// ==================== üöÄ –ó–ê–ü–£–°–ö –°–ï–†–í–ï–†–ê ====================
app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
  console.log('‚úÖ FXWave Crypto Bot is ready!');
});

// ==================== üîÑ –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö ====================
process.on('unhandledRejection', (reason) => {
  console.error('‚ùå Unhandled Rejection:', reason);
});

process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
});